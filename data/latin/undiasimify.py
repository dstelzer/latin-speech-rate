import re

STRESS = r'[ˈˌ]' # 02C8 02CC
# Generated by taking fullSymbolDiacriticDefs.txt and getting the hex(ord) of each character above 255
DIACRITIC = r'[\u02b0\u02b2\u02e0\u02b7\u1da3\u02e4\u02e1\u0303\u0308\u030d\u030a\u0325\u032c\u032a\u032f\u0329\u0330\u0324\u0339\u02d0]'
# A single alphabetic character, or two alphabetic characters joined by 0361 (tie bar)
IPACHAR = r'\w(?:\u0361\w)?' # The ?: makes this a non-capturing group, important for re.findall
# An alphabetic character plus any number of diacritics after it
PHONEME = fr'({STRESS}?{IPACHAR}{DIACRITIC}*)'

# Taken from symbolDefs.csv: these are all the ones that are +syl -cons
VOWEL = r'[əɜiyɪʏeøɛœæᴂaɶɨʉɘɵɞᴀɯuωʊɤoʌɔɑɒɐ]'
# These are all the ones that are +lat or appear rhotic in the author's view
LIQUID = r'[ɾrɹɬɮlɫɺʎʟʁʀ]'
# And these are all the ones that are -cont (except ʀ̆ which is not a stop)
STOP = r'[pbtdcɟkɡgqɢʔ]'
WAW = r'w'
VELAR = r'[kɡg]'

# 0329, 030d = syllabic
# 032f = not syllabic
SYLLABIC = r'[\u0329\u030d]'
NONSYLLABIC = r'\u032f'

def has(phon, pattern):
	return bool(re.search(pattern, phon))

def is_vowel(phon):
	return has(phon, SYLLABIC) or (has(phon, VOWEL) and not has(phon, NONSYLLABIC))
def is_liquid(phon):
	return has(phon, LIQUID) and not has(phon, SYLLABIC)
def is_stop(phon):
	return has(phon, STOP)
def is_waw(phon):
	return has(phon, WAW)
def is_velar(phon):
	return has(phon, VELAR)

class FrenchWord:
	def __init__(self, ipa, kw_correction=False, stress=True):
		self.ipa = ipa
		self.phonemify(stress)
		self.syllabify(kw_correction)
	
	def phonemify(self, stress=True): # Split continuous IPA into a list of phonemes (i.e. characters with diacritics attached)
		ipa = self.ipa if stress else re.sub(STRESS, '', self.ipa)
		self.phonemes = re.findall(PHONEME, ipa)
		if sum(len(p) for p in self.phonemes) != len(ipa):
			raise ValueError('Something got lost', ipa, ' '.join(self.phonemes))
	#	print(self.phonemes)
	
	def syllabify(self, kw_correction=False): # Split list of phonemes into list of syllables
		self.syllables = [[]] # (Where a syllable is a list of phonemes)
		initial = True
		
		for phon in self.phonemes:
			# First, give each vowel its own syllable, and put everything in the coda
			if is_vowel(phon):
				if initial: # (Exception: everything before the *first* vowel must be in the onset, so the first vowel does *not* make a new syllable)
					self.syllables[-1].append(phon)
					initial = False
					continue
				
				# But if it's not the first vowel we've seen, make a new syllable!
				newsyll = [phon]
				# Now, check if there's a consonant right before this. If so, stick it into the onset.
				if not is_vowel(self.syllables[-1][-1]):
					newsyll.insert(0, self.syllables[-1].pop()) # Remove it from the previous syllable and insert it at the start of this one
					# Now check for the special case of stop + liquid which is the only cluster we're allowing in onsets (I think?)
					if is_liquid(newsyll[0]) and is_stop(self.syllables[-1][-1]):
						newsyll.insert(0, self.syllables[-1].pop()) # Repeat the popping!
					elif kw_correction and is_waw(newsyll[0]) and is_velar(self.syllables[-1][-1]): # If we set the kw_correction flag, we also want kw and gw to remain together instead of being split across syllable boundaries
						newsyll.insert(0, self.syllables[-1].pop())
				self.syllables.append(newsyll) # Stick it into our list of syllables and start building a coda!
			else:
				self.syllables[-1].append(phon)
	#	print(self.syllables)
	
	def output(self, sep='-', phonsep=''):
		return sep.join(phonsep.join(p for p in s) for s in self.syllables)

if __name__ == '__main__':
	while True:
		print(FrenchWord(input()).output())
# Test case from FLLex: ˌɑd̪fˌɑkt̪ˈɑːre ˌɑd̪fˌɑxt̪ˈɑrɛ ˌaðfˌajt̪ʲˈie̯r ˌafˌɛt̪ʲjˈer ˌafˌɛt̪ˈer afɛt̪e
